Задача от Мегафона

Написано Варлашовым Р.П.

Развертка.
	
	Программа написана в Visual Studio 2013 Ultimate. Для тестирования в других средах разработки требуется закомментировать строчку (#include "stdafx.h").
	В папке Release лежит .exe.

Описание.
	
	Сначала читаем два числа, первое количество строк в таблице, второе количество столбцов. Далее читаем матрицу, параллельно инициализируя ее и вторую матрицу, которую будем использовать как промежуточный контейнер для сохранения значения на текущей итерации, построенного на основании прошлой итерации. Значение "1" в матрице обозначает наличие жизни в данной точке. Далее создадим два множества, одно также используется как контейнер. Эти множества будут хранить интересующие нас точки, то есть кандидатов на изменение на следующей итерации. Для чего это делать? Чтобы сократить количество рассчетов. В данном случае вместо пересчета n*m значений надо будет проверить всего k - количество кандидатов. При чтении матрицы поместим живые клетки в сет и на следующем шаге на основе них выберем кандидатов для 1-й итерации игры. Выведем начальное положение поля. "+" - наличие жизни, "-" - отсутствие.
	Создадим функцию hash_maker - которая будет создавать для текущего состояния матрицы три "уникальных" идентификатора. Так как, хранить все возможные состояния матриц довольно неоптимальное по памяти решение, то будет проще хранить три "уникальных" id. Которые будет хранить сет Uniq. И на каждой итерации мы просто за логарифм будем проверять совпадение нашего текущего id с уже имеющимися. Да, можно сказать, что данная методика сравнивания не дает 100% результат, но вероятность того, что две разных матрицы дадут три одинаковых числа по 3 разным "хэшам" - стремится к нулю. Поэтому в данной задаче, это имеет место быть. Далее мы запускаем симуляцию, считаем количество живых клеток вокруг клетки, на основе усливий задаем ей значение "1" или "0". Добавляем возможных кандидатов. Проверяем значение на совпадение, победу или поражение. Выводим вид игрового поля на текущей итерации. И продолжаем, либо заканчиваем выполнение программы. 

Запуск.
	
	Для корректной работы программы необходимо ввести два числа n, m - количество строк и стоблцов в игровом поле.
	Далее ввести матрицу, "1" - жизнь, "0" - отсутствие жизни. Сохранение переноса не обязательно. Можно ввести числа в один ряд.
	После программа начнет свою работу. На каждом шаге будет выводиться номер шага и текущее состояние игрового поля.
	В конце программа выдаст результат работы:
		- "Life win on step k", - то есть жизнь победила на шаге k.
		- "Death win on step k", - смерть победила на шаге k.
		- "Cycle exist on step k", - произошло зацикливание, то есть такая конфигурация поля уже встречалась.

Спасибо.